###Welcome to use MarkDown
1.onclick="window.loacation.reload()"						刷新页面
 					 window.history.go(1)									前进
 					 window.history.go(-1)									后退
 					 window.history.forward()								前进
 					 window.history.back()									后退
 					
history.back()无效
FireFox 改成 window.history.back()
Chrome 改成 window.history.back();return false;  （苹果移动端的退回方法）
	对于谷歌来说，首先执行window.history.back()	执行完成之后接着执行 href="#"，加上return false之后不再执行href，便能正常返回
		苹果移动端 <a href="#" onclick="javascript:window.history.go(-1);return false;"></a>
		
Javascript 刷新页面的几种方法：
#1. history.go(0)
#2. location.reload()
#3. location=location
#4. location.assign(location)
#5. document.execCommand("Refresh")
#6. window.navigate(location)
#7. location.replace(location)
#8. document.URL=location.href



2.overflow:auto 在移动端上滑动不灵敏，需要点击住一次，另一手指进行滑动
	解决方式：使用 touchstart touchmove touchend
	start 是滑动点击下去第一个点时候执行的
	move 是滑动一直执行的函数
	end 是滑动最后一个点执行的函数
	
	此处有代码
	var start1=document.getElementsByClassName('property_con1')[0];
	var x,y,end_x,end_y,x_x,y_y,move_x=0,move_y=0;
	start1.addEventListener("touchstart",function(evt){
		var touch=evt.touches[0];								//获取第一个点击点
		x=parseInt(touch.pageX);								//点击时候x坐标
		y=parseInt(touch.pageY);								//点击时候y坐标
		end_x=x;															//touchstart结束的x坐标
		end_y=y;															//touchstart结束的y坐标
	},false)
	start1.addEventListener("touchmove",function(evt){
		evt.preventDefault();										//阻止浏览器默认行为
		var touch=ent.touches[0];								//获取第一个点击点
		end_x=parseInt(touch.pageX);						//移动结束x坐标
		end_y=parseInt(touch.pageY);						//移动结束y坐标
		x_x=end_x-x;													//点击点x移动了多少
		y_y=end_y-y													//点击点y移动了多少
		move_x+=(x_x*-1)/20;									//想让元素移动的距离 根据情况自定义设置
		move_y+=(y_y*-1)/35;									//想让元素移动的距离 根据情况自定义设置
		var widthx=$(".property_con1").eq(0).children('table').width()-$(".property_con1").eq(0).width();		//超出当前显示框的表格长度
		var heighty=$(".property_con1").eq(0).children('table').height()-$(".property_con1").eq(0).height();//超出当前显示区域的表格高度
		if(move_x<0){move_x=0};				//如果移动的距离小于0 就让它变成0	(不要超出移动范围/最小值)
		if(move_y<0){move_y=0};				//如果移动的距离小于0 就让它变成0	(不要超出移动范围/最小值)
		if(move_x>widthx){move_x=widthx};		//如果移动的距离大于隐藏距离 则变成隐藏距离 (最大值)
		if(move_y>heighty){move_y=heighty};	//如果移动的距离大于隐藏距离 则变成隐藏距离 (最大值)
		$(".property_con1").eq(0).children('table').each(function(index,obj){
			$(obj).css('transform','translate(-'+move_x+'px,-'+move_y+'px)')
		})
	},false)
	start1.addEventListener('touchend',function(evt){
		var x_x=end_x-x;											//x移动了多少
		var y_y=end_y-y;											//y移动了多少
	},false)
	


3.xxx.bind("input propertychange(IE专属)",function(){})
	当input里的值改变时候就会执行函数，无论是鼠标的复制粘贴还是键盘的改变
		比较好的监听输入框改变事件
		
	
	
4.对于获取数据错误的改动 添加延迟执行



5.模糊查询 判断指定字符是否存在于字符串中
	$(obj).text().indexOf(str)>=0	如果为-1则表示没有
	


6.find() 查找后代元素 或者在选择器里用空格隔开



7.CSS3 伪类选择器		:nth-child
	#1. :nth-child(number) 		字节匹配第number个元素，参数number必须为大于0的整数
	#2. :nth-child(an)					匹配所有倍数为a的元素，参数an中的字母n不可少
	#3. :nth-child(an +/- b)
	
	
	
8.js获取当前文件所在文件夹全路径
var js=document.scripts;
console.log(js);
js = js[js.length-2].src.substring(0,js[js.length-2].src.lastIndexOf("/")+1);
console.log(js);



9.父元素.appendChild(添加内容)
在父元素的里面添加内容 如果内容已经存在 则内容后变成最后一个子元素



10.CSS3 box-shadow
六个值
	-1-水平阴影的位置 允许负值
	-2-垂直阴影的位置 允许负值
	-3-可选 模糊距离
	-4-可选 阴影的尺寸
	-5-可选 阴影的颜色
	-6-可选 将外部阴影outset改为内部阴影
	


11.关于同步和异步
var a=0;
function get(){
	//从服务器获取数据  
	a=数据1;
}
console.log(a)		
a还是0;			因为js是异步执行的 在上面还在获取的同时 下面就已经console.log了出来 
						除非加延迟 或者执行回调函数

解决
var a=0;
function get(){
	//从服务器获取数据
	a=数据1;							这样的话就变成了同步加载 在上面获取完数据会 立马console.log
	changea()		
}
function changea(){
	console.log(a);
}



12.
如何给有参函数设置默认值(三种)
function example(a.b){
	var a=arguments[0]?arguments[0]:1;			//设置参数a的默认值为1
	var b=arguments[1]?arguments[1]:2;			//设置参数a的默认值为2
}
										↓
function example(){
	var a=arguments[0]?arguments[0]:1;			//设置参数a的默认值为1
	var b=arguments[1]?arguments[1]:2;			//设置参数a的默认值为2
}


function example(a,b){
	a=a||"默认参数";
	b=b||"默认参数";
}
					↓
function example(a,b){
	if(!a){a="默认参数"};
	if(!b){b="默认参数"};
}


第三种方法，适用于参数较多的情况，使用Jquery扩展
function example(setting){
	var defaultSetting={
		name:'小红',
		age:'30',
		sex:'女',
		phone:'88888888',
		QQ:'123123',
		birthday:'1996.02.22'
	};
	$.extend(defaultSetting,setting);
	var message='姓名:'+defaultSetting.name+',性别:'+defaultSetting.sex
	+',年龄:'+defaultSetting.age+',电话:'+defaultSetting.phone+',QQ:'+defaultSetting.QQ+',生日:'+defaultSetting.birthday+'。'
	alert(message);
}

example({
	name:'小红',sex:'女',phone:'100866'
})



13.
debugger 代码版的打断点



14.
百度地图获取当前缩放比例的函数 map.getZoom();
以及 百度地图方式大全
developer.baidu.com/map/reference/index.php?title=Class:极速版核心类/map#.E4.BA.8B.E4.BB.B6



16.
Echarts
http://echarts.baidu.com/option.html#series-bar.itemStyle 指南



17.
关于移动端每次打开页面缓存问题
html代码
<meta http-equiv="cache-control" content="max-age=0" />
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="expires" content="0" />
<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
<meta http-equiv="pragma" content="no-cache" />

css代码
<link rel="stylesheet" type="text/css" href="../skin/css/index.css?v=20170627">
加自定义版本号
 
js代码
代码													//每次的url都是一个新的路径 都会重新访问
function timestamp(url){
	var getTimestamp=new Date().getTime();
	if(url.indexOf("?")>-1){
		url=url+"&timestamp"+getTimestamp
		return;
	}else{
		url=url+"?timestamp"+getTimestamp
	}
	window.location.href=url;
	return url;
}
timestamp(window.location.href)



18.
关于更新版本提示 打开若干次 只提示一次的问题 
利用cookie解决 引入jquery.cookie.js文件
var a=$.cookie("count");
$.cookie("count","123",{expries:30});		设置cookie



19.
关于固定表格(类似表头，表格左边)的滑动
clone()	jq克隆 复制指定元素的文本子节点以及属性
括号里面为true时候 则复制事件
用此来解决 移动表格时候的表头固定或者第一列固定 
在第一次触碰时候 设置一个全局变量 并判断 是否继续添加元素
克隆的元素设置为绝对定位 left 0
代码如下
var start1=document.getElementsByClassName('property_con1')[0];
	var xxx=true;
	start1.addEventListener("touchstart",function(evt){
		if(xxx){																								//先进行判断是否添加 不可以在下方循环里面进行添加
			$(".property_con1 tr").each(function(index,obj){				//因为这个是根据点击的来进行判断 写在外面
				$(obj).append($(obj).children("td:first").clone());
				xxx=false;
			})
		}
		$(".property_con1 tr").each(function(index,obj){					//进行克隆元素的定位 left 0 绝对定位
			$(obj).children("td:last").css({
				"position":"absolute",
				"left":"0"
			})
			if(index%2==0){																			//隔行换色
				$(obj).children("td:last").css({
					"backgroundColor":"#f5f5f5"
				})
			}else{																								//隔行换色
				$(obj).children("td:last").css({
					"backgroundColor":"white"
				})
			}
		})
	},false)
	start1.addEventListener("touchmove",function(evt){
		$(".property_con1 tr").each(function(index,obj){					//在进行移动的时候 也定位到左边
			$(obj).children("td:last").css({
				"position":"absolute",
				"left":"0"
			})
		})
	},false)
	start1.addEventListener('touchend',function(evt){
		结束时候并不用写什么东西
	},false)



20.
关于固定了高度 使其内容垂直居中 
如果文字只有一行 则可以设置line-height设为元素高度
<p>这里是一行文字设置成line-height可以垂直居中</p>

而如果文字不固定 会有很多行
<p>这里是两行文字<br/>垂直居中的话 不能使用line-height属性 在里面包含一个元素设置line-height也不可以</p>
解决方式 在外层元素加上 display:table-cell 属性 和 vertical-align:middle 如果内层还有元素的话 则加上 display:inline-block;
原	理 把内部元素 当成图片处理 设置成和图片一样的display属性(inline-block) 并且在外层加上 vertical-align:middle
	注:外层元素不可以浮动 absolute,fixed,float等 



21.
关于在元素内 给图片 设置完全居中
方法1：
<div><img src="一张透明的gif图" style="background-image:url(http://www.这是需要展示的图)"><div>
原理 给外层的 div设好固定宽高后 给内层的img src添加一张 透明的gif图片 
然后 设置 background-position:center 和 background-repeat:no-repeat
 使其的背景图 在中间 并且 不重复 利用背景图的属性

方法2：



22.
关于display的值 table-cell IE8+(含8)
缺点		 不可以同position:absolute以及float同用 对width height敏感 无视margin 响应padding 类似与td标签



23.
关于删除所有cookie
function clearCookie(){
	var keys=document.cookie.match(/[^=;]+(?=\=)/g);
	if(keys){
		for(var i=keys.length;i--;){
			document.cookie=keys[i]+'=0;expires='+new Date(0).toUTCString()
		}
	}
}



24.
关于元素有时设置成inline-block时也会有间距的问题 可能为html元素内 换行所导致



25.
jq解除所有事件绑定 $("#shoushi").unbind();
括号内也可以设置需要解绑的事件 ， 引号括起来



26.
关于一个兼容性问题 div嵌套行内快元素 inline-block 时，如果元素换行后，会有margin-bottom:4px的默认值。
解决方式1:
需要给行内块元素设置 margin-bottim:-4px
解决方式2:
给被嵌套元素 设置为 display:block 并且设置 float:left
解决方式3:
添加vertical-align:middle
类似网址 



27.
关于如何给png图片改变图片颜色
<div id="waiceng">
	<div id="neiceng"></div>
</div>
#waiceng{
	width:100px;height:100px;overflow:hidden;
}
#neiceng{
	width:100%;height:100%;position:relative;
	background:url(图片路径) no-repeat;
	background-size:100px 100px;
	-webkit-filter:drop-shadow(颜色 20px[偏移多少距离] 0/1[是否显示复制出来的图片])；
	filter:drop-shadow(颜色 20px[偏移多少距离] 0/1[是否显示复制出来的图片]);
	left:-偏移距离(不可以大于外层div的宽度 不可以大于100px);
	border-right:20px solid transparent;
}
原理制造一个背景图镜像 并且可以改变填充颜色 让原图片偏移 让镜像图片显示



28.
关于声明全局函数
可以把整个window当成一个对象，然而 在函数外声明的变量，是全局变量。其实全局变量只是一个相对概念，因为最大的对象是window 
如果window外还有对象的话，那所说的全局变量就是局部变量了。
那么，既然window是个对象的话，
加不加var的区别就是，是否把这个当成变量声明，还是当成window对象使用，
如果当成变量声明的话，也就是加上var的话 那么看此变量声明的位置，如果在函数内那就是局部变量，如果在最外层也就是类似于window层声明的话，
那就是全局变量，
而如果不加var的话，在函数内写的话，会解读成window的属性，所以就会当成全局变量处理。

加var的话会变成全局变量，如果在函数内声明则为局部变量
不加var的变量会在当前作用域链内解析，如果找到会重新赋值，如果没有找到，会在全局对象(即当前作用域链的最顶层对象，如window对象)
中创建并且赋值，和全局变量有本质的区别。

var num1=1;num2=2;
delete num1;delete num2;
再次console.log时候 会发现全局变量依旧存在，属性会被删除
并且 只有在变量或者属性声明后才可以使用。

但是函数 可以在底部声明 全局内都可以使用 详见下一条


28-1.
关于函数声明的问题
在JS中，定义函数有两种方式。分别为，函数语句 和 表达式。
	函数语句
		function yuju(){console.log(111)}
	表达式
		var yuju1=function(){console.log(222)}
		
而 函数语句 可以先使用再定义 但是 表达式就不行
	原因是
		JS有一个全局默认对象 window 
		在执行一段函数的时候 会先把全局变量都绑定到window上 此时 window有yuju函数(包括函数体)和yuju1变量(但是值为undefined)
		在执行代码的时候 虽然 还没有执行到 yuju函数 但是 window对象上已经绑定了 所以可以使用
		而没有执行到 yuju1变量的赋值前 yuju1为undefined  所以必须要在变量(var表达式)声明后才可以使用变量 不然为undefined  



29.
一些有意思的面试题
-1.
		alert(a);
		a();
		var a=3;
		function a(){
		    alert(10)
		}   
		alert(a)
		a=6;
		a();
结果为：function a(){alert(10)}    10    3    报错
				函数声明大于变量声明 所以第一次弹框为 function a(){alert(10)};			//函数声明大于变量声明
				第二次为运行函数 所以弹框为10
				第三次给a赋值3 所以弹框3
				第四次 a不是函数 所以 加括号会报错



30.
关于iframe标签的用法
隐藏iframe表框 
var myifram=document.getElementById("myiframe");
myiframe.style.border="none";//myiframe.setAttribute("frameborder",0);//myiframe.frameBorder = 0;

动态创建iframe
var newiframe=document.getElementById("myiframe");
newiframe.src="http://www.xxx.com";
newiframe.frameBorder=0;
newiframe.width="400px";
newiframe.height="100%";
newiframe.scrolling="no";



31.
关于立刻执行函数 进阶阅48
(function(){
	//没有绑定任何事件，也无需等待异步操作
})()
包围它的一对括号把他转换为表达式，紧跟的一对括号调用了这个函数。
立即执行函数也可以理解为立刻调用一个匿名函数。
使用场景：把var变量的作用域限制于函数内，可以避免命名冲突、



32.
关于闭包
function f1(){
	var x=0;
	function f2(){
		x++;
		return x;
	}
	return f2;
}
var xx=f1();
var xxx=xx()*xx()*xx();
console.log(xxx);			//6



33.
私有变量



34.
关于数组去重的函数	(原理,利用indexOf[搜索指定内容,返回内容下标,如无,返回-1],查看下标,循环的下标和搜索出下标对比,看是否相等,判断是否重复)
		var arrxx=[1,1,1,1,1,1,2,2,2,2];
		console.log(arrxx);
		function quchong(arr){
			var newArr=[];
			for(var x=0;x<arr.length;x++){
				if(arr.indexOf(arr[x])==x){						//在传入的arr里寻找 循环的值 ，如果发现下标相等，也就是寻找的值在第一个。
					newArr.push(arr[x]);								//那就放到新数组里
				}
			}
			return newArr;													//返回新的数组
		}
		arrxx=quchong(arrxx);										//把去重后的数组 赋给当前需要去重的数组
		console.log(arrxx);
		
		
		let newname=[...new Set(arr)]													//ES6数组去重



35.
height:0 width:0 overflow:hidden                



36.
关于一个元素绑定了多个相同事件，如何取消其中的特定事件
<button>按钮</button>
$("button").on("click.name",function(){
	alert(111)
})
$("button").on("click.papa",function(){
	alert(222);
})
$("button").unbind("click.name")            
						或者
function abc(){
	alert(111)
}
function cba(){
	alert(222)
}
$("button").on("click",abc);
$("button").on("click",cba);
$("button").unbind("click",abc);    			//取消abc的click事件                  



37.
关于事件委派，事件代理的。
$("fu").delegate("zi","shijian",function(e){
	e.preventDefault();
	console.log($(this).index())
})
或
$("fu").on("shijian","zi",function(e){
	e.preventDefault();
	console.log($(this).index())
})
适用场景，对于。html代码用js生成的。
就算需要绑定的元素以前就存在，还是要 事件委派。
经测试，如果html元素不变，可以使用常规绑定事件获取下标。
如果html代码经js改变后，需要用事件代理。

如果想给img解除委托事件的话，需要给$("fu")进行解绑
$("#xiangmutu").unbind("click.a");
$("#xiangmutu").on("click.a","img",function(){})



38.
关于适用于定位的滑动 全自动适应(左右滑动版)
适用场景 九宫格图片轮播图左右滑 自适应
var html="",html1="",arrrr=[];
for(var x=0;x<$(".xiangmutu img").length;x++){
	if((x+1)%9==1){																										//判断img是否是九宫格的第一个,如果是 外面添加div
		html+="<div class='huadong' style='left:"+(x/9)*100+"%'>";				//给外包的div设置自动浮动
	}
	html+=$("#xiangmutu img")[x].outerHTML;													//加上每个img
	if((x+1)%9==0){																										//判断img是否是九宫格的最后一个,如果是 加闭合div
		html+="</div>"
	}
}
$("#xiangmutu").html(html);
html1+="<ul id='tu_ul'>";																						//添加下方序列小图标
for(var x=0;x<$(".huadong").length;x++){
	html1+="<li class='ul_li'></li>";																		//根据滑动页面数量添加li
}
html1+="</ul>"																											//添加闭合div
(function(){																													//使用匿名函数 为了保持同步执行 
	$("#xiangmutu").append(html1);
	$(".tu_li:first").css("backgroundColor","#ff8800");										//如果不是用函数 循环会比加颜色执行的慢 导致颜色加不上
})()
var xiangmu=doument.getElementById("xiangmutu");		
var start_endx,move_endx,move_x,duibi,indexx=0,a=true;
xiangmu.addEventListener("touchstart",function(e){
	var touch=e.touches[0];
	start_endx=touch.pageX;															//获取点击第一个点的位置
})
xiangmu.addEventListener("touchmove",function(e){
	e.preventDefault();
	var touch=e.touches[0];									
	move_endx=touch.pageX;														//获取每次移动的位置
	move_x=move_endx-start_endx											//和第一个点的位置相减
})
xiangmu.addEventListener("touchend",function(){
	//因为存在九宫格图片的点击和滑动并存的事件，所以需要判断。
	//如果move_x未赋值说明没有手指没有滑动，声明后未赋值为undefined 以及和上次滑动的距离相同 以及点开图片后不可滑动
	if(move_x==undefined||duibi==move_x||!a){return false;};
	if(move_x>0){																			//判断下标滑动	大于0滑动的最后一个点比触碰的第一个点大 为向右滑 向左滚
		if(indexx==0)return false;												//如果index为0终止
		$(".tu_li").css("backgroundColor","white");				//复原所有以颜色
		indexx--;
		$(".tu_li").eq(indexx).css("backgroundColor","#ff8800")
	}else{
		if(indexx==$(".huadong").length-1){return false};		//index从0开始,length为个数,所以如果index为个数减一,数量相同时候，终止
		$(".tu_li").css("backgroundColor","white");					//复原所有颜色
		indexx++;
		$(".tu_li").eq(indexx).css("backgroundColor","#ff8800");
	} 
	$(".huadong").each(function(index,obj){											//给滑动页面遍历
		if(move_x>0){																							//根据正负来判断是向左滑还是向右滑 
			//判断第一个元素的left值除以宽度是不是整数(是否是滚动了一个滑动页宽度),不是整数则return false或者第一个的left值为0(最左边)
			if(!Number.isInteger(($(".huadong:first").css("left").split("px")[0]-1+1)/$(".huadong:first").width())||$(".huadong:first").css("left")=="0px"){return false;}
			$(obj).css({																							//如果第一个滑动的页面left为0 return false(最左边了)
				"left":$(obj).css("left").split("px")[0]*1+$(obj).width(),		//每个滑动页面的left值为 当前的left加上一个滑动页面的宽度
				"transition":"all .5s"
			})
		}else{
			//判断第一个元素的left值除以宽度是不是整数(是否是滚动了一个滑动页宽度),不是整数则return false或者最后一个的left值为0(最后边)
			if(!Number.isInteger(($(".huadong:first").css("left").split("px")[0]-1+1)/$(".huadong:first").width())||$(".huadong:last").css("left")=="0px"){return false;}
			$(obj).css({
				"left":$(obj).css("left").split("px")[0]*1-$(obj).width(),			//每个滑动页面的left值为 当前的left加上一个滑动页面的宽度
				"transition":"all .5s"
			})
		}
	})
})


 
39.
关于是否为整数的判断
ES6
Number.isInteger("1")		false;					Number.isInteger(1.1)		false;
Number.isInteger(1)			true;  



40.
屏幕不缩放 以及 判断当前屏幕宽高



41.
NodeList和Array的区别
NodeList是dom操作取出来的集合，与数组相似但不是数组，有一些相同的属性length下标等，但是不可以使用原生数组的方法，push pop等
NodeList最大特点是时效性(及时更新)；所谓时效性，就是在修改li的同时会及时反应到lis上
var lis = myUl.getElementsByTagName('li'); 为NodeList集合；
NodeList集合转化为数组
function collectionToArray(collection){ 
	var ary = []; 
	for(var i=0, len = collection.length; i < len; i++){ 
		ary.push(collection[i]); 
	} 
	return ary; 
}



42.
关于querySelector和querySelectorAll的区别
querySelector返回的是元素。
是在指定元素内查找根据CSS选择器指定的元素。
只会返回查找出的第一个元素。
如果没有匹配的元素则会返回null。
可以是document.querySelector("#aa")或者document.getElementById("#aa").querySelector(".bb");
querySelectorAll返回的是NodeList对象。
是在指定元素内查找根据CSS选择器指定的所有元素。
会返回一个NodeList对象。
如果没有匹配元素则会返回一个空的NodeList集合。
可以是document.querySelectorAll(".aa")或者document.getElementById("#aa").querySelectorAll(".bb")



43.
关于setTimeout等异步的执行顺序
console.log("start");
setTimeout(functon(){
	console.log("hellow")
},200);
setTimeout(function(){
	console.log("world")
},100)
console.log("end")
执行结果 start end world hellow

js引擎会在内存中分配堆区和栈区
function A(){
	var a=3;
	B(3);
}
function B(num){
	var newNum=num*num;
	console.log(newNum)
}
A();
左边为代码				右边为栈
1.运行A()方法，将A()入栈，此时A上下中文存在变量a=3;
2.然后往下执行 调用B()方法，B()入栈，B上下文中存在变量num=3,newNum=9
3.调用B()方法中的console.log，将console.log入栈
4.然后执行}将console.log和B()方法出栈
5.A()方法运行}完毕，将A方法出栈
6.代码运行完成，清空栈

Event Loop(事件循环)
javascript引擎是单线程的，在某一个特定时间，只能执行一个任务，并阻塞其他任务的进程，所有任务都是串行的。
所以用户必须等待一个耗时任务执行完成后，在执行下一个任务。
当异步方法比如setTimeout();ajax请求;DOM事件执行的时候，会交由浏览器内核的其他模块管理。
当异步请求满足触发的条件的时候，该模块会将方法堆到一个任务队列中，
当主线程代码执行完毕会，就回去检查任务队列，将其中的第一个入栈执行，如此循环。
前提是主线程处于空闲状态，这就是事件循环的模型。

console.log("start");
setTimeout(function(){
	console.log("3秒")
},3000);
setTimeout(function(){
	console.log("2.5秒")
},2500)
for(var x=0;x<30000;x++){
	console.log(x)
}
setTimeout(function(){
	console.log("1秒")
},1000)
console.log("end");
结果为 start end 2.5秒 3秒 1秒

1.主线程开始执行 start
2.把 3秒 和 2.5秒 入栈
3.主线程继续进行循环 大于1秒
4.执行完成后把 1秒 入栈
5.执行end
6.主线程执行完毕 执行栈内内容
7.根据setTimeout的时间进行执行
8.栈内内容优先级为 2.5秒 3秒 1秒(循环大于1秒，循环完成后把1秒入栈，同时其他定时器也在走时间，2.5秒小于3秒。2.5秒先执行，后3秒，后1秒)



44.
关于attr()和prop()选取布尔属性的异同
attr和prop都为读取属性值或者设置属性
但是如果用attr读取布尔类型的属性 类似 checked 如果勾选会返回 checked 如果未选中 会返回 undefined
如果用prop读取 如果勾选会返回 true 如果未勾选 会返回 false
用attr()或者prop()的情况:
1.添加属性名称该属性就会生效的[布尔]使用prop();
2.只有true和false两个属性时候使用prop();
3.其他情况使用attr()；



45.
关于slice截取字符串 数组 包前不包后
<input type="text" placeholder="输入数字评分 最高10分">
<button>点击/清空</button>

var btn=document.querySelector("button"),rate;
btn.onclick=()=>{
	if((typeof document.querySelector("input").value)==Number){document.querySelector("input").value=""}
	rate=document.querySelector("input").value;
	document.querySelector("input").value="★★★★★★★★★★☆☆☆☆☆☆☆☆☆☆".slice(10-rate,20-rate);
}
var x=3,str="◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◇◇◇◇".slice(10-x,20-x);
console.log(str);
原理:
	.slice(起始坐标，结束作弊);
	截取20字符串中间的一截字符串/起始坐标为实心的长度-需要显示的长度/结束坐标为总长度-需要显示的长度			//截取字符串
	var arr=[1,2,3,4,5,6,7];							
	var arrx=arr.slice(1,6)
	console.log($.isArray(arrx));					//截取数组
		
	
	
46.
关于toString()的补充
	toString()函数用于将当前对象以字符串形式返回
	1>Array				返回 将Array的[每个元素转换为字符串]，并且用英文逗号连接起来;
		var x=[1,2,true,"false"];
		console.log(x);
		console.log(x.toString().split(","));
		
	2>String			返回 String对象的值
		var x='[1,2,true]';
		console.log(x);
		console.log(x.toString());
		
	3>Date				返回 日期的文本表示;
		var x=new Date();
		console.log(x.toLocaleString());									//返回类型为对象
		console.log(x.toString().toLocaleString());				//返回类型为字符串类型 所以无效
		
	4>Error				返回 一个包含相关错误信息的字符串;
	5>Function		返回 function functionname(){code};
		var x=function abc(){console.log(111)};
		console.log(x);
		console.log(x.toString());
		
	6>Number		返回 数值的字符串表示。[还可以返回指定进制表的字符串];	←详情见下一条记录
		var x=123;
		console.log(x);																	//数字类型
		console.log(x.toString());												//字符串类型
		
	7>Boolean		返回 如果Boolean是true返回"true",如果是false返回"false";
		var x=true;
		console.log(x);
		console.log(x.toString());
		
	8>Object			返回 "[object ObjectName]"，其中 ObjectName 是对象类型的名称。
		var x=document.querySelectorAll("html");
		console.log(x);
		console.log(x.toString());											//object NodeList
		
		var x=document.querySelector("html");
		console.log(x);
		console.log(x.toString());											//object HTMLHtmlElement



47.
关于随机取字符串
console.log(Math.random().toString(16).substring(2));
	Number.toString([参数]);
	参数支持[2,36]之间的整数，表示以多少进制转换为字符串 默认为10
	
subString(2)截取字符串从多少开始 包前不包后



48.
关于匿名函数自调用的多种方法
	1>	(function(){}());
	2>	[function(){}()];
	3>	(function(){})();
	4>	!function(){}();
	5>	~function(){}();
	6>	+function(){}();
	7>	-function(){}();
	8>	delete function(){}();
	9>	typeof function(){}();
	10>	void function(){}();
	11>	new function(){}();
	12>	new function(){};
	13>	var x=function(){}();
	14>	以及 a=0^或者&或者*或者-或者+或者|或者||或者,或者.或者<或者>或者/或者%function(){console.log(111)}();
				document.querySelectorAll("div")/function(){console.log(222)}()		//只要前面不为undefined以及报错就可以



49.
关于元素大小改变事件
JS:onresize			JQ:resize()



50.
关于void的一些小故事
js会把为赋值的变量置为undefined	如果要强行赋值undefined那么使用void
void是javascript中的一个操作符，对传入的值不进行操作并返回undefined，不管传入的是 null undefined infinity 或者 123
类似 <a href="javascript:void(0)"></a>
实际用途不再赞成使用 void 他的出现是为了兼容 ECMAScript标准中没有undefined属性



51.
关于取整
var x=2.5222;
parseInt与parseFloat是将字符串转换为数值类型，他们在遇到不是数字时候，将会截取前面是数字的部分转换为数值。
	1>x.toFixed()*1								//toFixed() 会把小数四舍五入变成字符串 再通过隐式转换
	2>parseInt(x)									//parseInt 会把数字截取成整数 不会四舍五入 返回类型为number
	3>Math.ceil(x)									//Math.ceil() 会把数字向上取整
	4>Math.floor(x)								//Math.floor() 会把数字向下取整
	5>Math.round(x)							//Math.round() 会把数字四舍五入的取整
	6>a|0	/	a~~0	/	a>>0					//效果类似与parseInt()	不会四舍五入，为截取整数



52.
关于不使用第三个变量交换两个变量的数值
	1>	[a,b]=[b,a]
	2>	a^=b;b^=a;a^=b;
	3>	a+=b;b=a-b;a-=b;



53.
关于标签回车页面多出空格，font-size:0px;



54.
关于字符串操作

	1>for of
	遍历字符串
var str="fighting !!";
for(x of str){console.log(x});

	2>str.includes()
	是否包含,以及可以指定从什么位置查看											从指定位置到结束
console.log(str.includes("fight"));				//true
console.log(str.includes("ght",3))	;			//false
console.log(str.includes("ght",2))	;			//true			(遵循包前不包后原则)

	3>str.startsWith()
	是否以指定字符串开头,以及可以指定从什么位置查看					从指定位置到结束
console.log(str.startsWith("fight"))			//true
console.log(str.startsWith("ght",3))			//false
console.log(str.startsWith("ght",2))			//true			(遵循包前不包后原则)

	4>str.endsWith()
	是否以指定字符串结尾,以及可以指定位置										从指定位置到开始，前N-1个字符		(包前不包后原则)
console.log(str.endsWith(" !!"))					//true
console.log(str.endsWith("ing ",9))			//true
console.log(str.endsWith("ing"),7)			//false

	5>str.repeat()
	重复指定字符串
var str="x";
str.repeat(2);					xx		
str.repeat("2");				xx						字符串会转换成数字
str.repeat(3.9);					xxx						向下取整
str.repeat(0);					没东西					0为重复0次 没有
str.repeat("a");				没东西
str.repeat(NaN);				没东西
str.repeat(-.9);					没东西
str.repeat(-1/-2)				报错
str.repeat(Infinity)			报错

	6>str.padStart()/star.padEnd()
	字符串自动补充，如果字符串不够指定长度
var str="abcdefg";
str.padStart(10,"1");					111abcdefg				//常规
str.padStart(10,"123456")		123abcdefg				//会把超出指定长度的其余截取掉
str.padEnd(7,"123456")			abcdefg						//如果指定长度小于或者等于本身长度 泽返回本身
str.padStart(70)																//如果未写参数，会用空格补充

	7>`模版字符串`
	模板字符串是增强版的字符串，用反引号`标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。



55.
css的border不可以设置百分比



56.
关于文字两端对齐的CSS样式

text-align:justify;						不针对文字最后一行起效
text-align-last:justify;				对文字最后一行起效

div{text-align:justify}
或者在标签内加上<i></i>	设置width100%//padding-left:100%; display:inline-block;
或者 div:after{content:"";width:100%;//padding-left:100%;display:inline-block};
此两个方法会多出一行 原理为在文字后多加一行 是其不成为第一行
如果文字有第二行第一行就不用两端对齐了



57.
关于解决循环变量名的方法
var objectx={};
for(let x=0;x<10;x++){
	objectx['name'+x]=[];
	for(let z=0;z<5;z++){
		objectx['name'+x].push(Math.ceil(Math.random()*9))
	}
}
console.log(objectx);



58.
关于"`"的循环 从对象中循环取值
let str="";
for(let x=0;x<5;x++){
    str+=`<div class="fenzhi_you_list"><div>${name['name'+(x+1)]}</div><div>${value['value'+(x+1)]}</div></div>`
}
在变量名中用字符串



59.
关于数组是引用传递还是赋值传递
let arr=[1,2,3,4,5];
let arr1=arr;
console.log(arr1);					1,2,3,4,5
arr.unshift("这是对数组对象的操作");
console.log(arr1);					这是对数组对象的操作,1,2,3,4,5
arr=[5,4,3,2,1];
console.log(arr1);					这是对数组对象的操作,1,2,3,4,5
arr.unshift("这是对arr新指向数组的操作");
console.log(arr1);					这是对数组对象的操作,1,2,3,4,5

	1>
	let arr=[1,2,3,4,5];
	let arr1=arr;				arr1 和 arr	同时指向了 [1,2,3,4,5]；
	此时有３部分,分别为:		数组[1,2,3,4,5]	变量arr 变量arr1;
	2>
	当执行arr.unshift("这是对数组对象的操作");
	改变了数组[1,2,3,4,5]的数据，arr1也指向了[1,2,3,4,5]，所以arr1的值会改变;
	3>
	当执行arr=[5,4,3,2,1];
	改变了变量arr的指向对象,由[1,2,3,4,5]改变为了[5,4,3,2,1];
	并没有和arr1有所关联，所以arr1的值不会改变
	4>
	当执行arr.unshift("这是对arr新指向数组的操作");
	这时是改变的[5,4,3,2,1]的值，与arr1没有关系
	
两个数组等号赋值，如果都未曾改变变量的指向，那么为引用传递，一个改变其他一个也会改变
当有等号时候，arr=arr1;	他们都同时指向了同一个数组 
如果通过数组操作改变指向数组的值，那么 arr和arr1都会改变。（通过属性操作改变数组，都会改变）
如果通过赋值改变了其中一个变量的指向，另一个变量不会改变。（通过赋值改变变量的指向，只会改变一个）



60.
toString()与valueOf()
toString()详见46
valueOf() 如果对象存在任意原始值，就默认将对象转化为表示它的原始值。
				   对象为复合值的话，大多数对象无法真正表示为一个原始值，因此默认的valueOf()只是返回对象本身，而不是返回一个原始值
	日期类定义的valueOf()会返回它的一个内部表示 从1970年1月1日到现在的毫秒数
	原始值：不可变更的值，包括undefined、null、布尔值、数字、和字符串



61.
关于 [] 转换延展的问题
!![]=true			//true
[]=true				//true
![]=[]					//true



62.
关于splice()与slice();
splice()↘	在指定位置添加或删除元素 会修改原数组
三个参数	分别为 
index/必需 要在哪个位置增加或者删除元素(数值为下标元素)
howmany/必需 要删除多少个元素
item1,...,itemX/可选 想数组添加新的项目
如果有返回值的话，返回被修改后的数组(原数组)

var arr = new Array(6)
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"
arr[3] = "James"
arr[4] = "Adrew"
arr[5] = "Martin"

document.write(arr + "<br />")
arr.splice(2,0,"William")
document.write(arr + "<br />")

George,John,Thomas,James,Adrew,Martin
George,John,William,Thomas,James,Adrew,Martin

slice()↘ 从指定位置截取数组 不会修改原数组
两个参数 分别为
start/必需 规定从何处开始截取数组 
		如果值为负数 则从后往前开始截取  -1为最后一个元素 -2为倒数第二个元素
end/可选 规定从何处结束选取 该参数是数组片段结束处的下标 
		如果没有该参数 则为start到结束的所有元素 
		如果是负数 则从尾部往前算起
		


63.
关于判断屏幕是旋转（横竖屏旋转）还是大小改变
'orientationchange' in window ? 'orientationchange' : 'resize'

"orientationchange"事件是用户水平或者垂直翻转设备(即方向发生改变)是触发的事件；
$(window).on("orientationchange",function(event){
	console.log(event.orientation);
})
可以访问属性 事件源属性 orientation 值为 portrait(纵向) landspace(横向)

"resize"/resize()	是在浏览器窗口改变时候触发的事件
  


64.
关于移动端配置自适应屏幕
rem是根据html的font-size来计算的
所以如果要写自适应 就要 让html的font-size根据不同屏幕来进行换算

以iphone6为例子 字体大小设置为20px iphone6屏幕为375*667
js代码
window.addEventListener(("orientationchange" in window?"orientationchange":"resize"),+function(){
	~function(){
		var d=document.documentElement;
		var widthx=d.clientWidth||750;
		d.style.fontSize=(20*(widthx/375))>40?40+"px":(20*(widthx/375))+"px"
	}()
}(),false)
jq代码
$(window).on("orientationchange" in window?"orientationchange":"resize",!function(){
	$("html").css("fontSize",20*($("html").innerWidth()||750)/375>40?40+"px":20*($("html").innerWidth()||750)/375+"px")
}())



65.
关于移动端和PC端视口

如果给元素设置 width:100%;height:100%;时候 width会生效，因为浏览器的宽度会有个顶峰 而height不会
但是 如果给 body 或者 html 设置 width:100%;height:100%;时候 height会生效 
而百分比是继承父元素的 所以是在继承哪里的呢？

\布局视口/
在PC浏览器中，有一个用来约束CSS布局视口的东西，又叫做初始包含块，这就是width和height继承的由来
除去margin,padding 布局视口和浏览器的可视宽度是一直的，同时又和浏览器本身的宽度一致

在移动端中，在默认情况下，布局视口的宽度是远远大于浏览器宽度的，并且他们是互相独立存在的。
浏览器厂商为了让为了让用户在小屏幕下也能显示的很好，所以把布局视口宽度设置的很大，一般为768px~1024px之间，最常见的宽度为980px
可以通过 document.documentElement.cilentWidth 获取到

\视觉视口/
是呈现给用户的，是用户看到网页区域内CSS像素的数量，由于用户可以自由缩放，所以并不是开发者需要特别关注的

在移动端，缩放时候，不会改变布局视口的大小，缩小时，屏幕覆盖的CSS像素变多，视觉视口会变大，布局视口不变，反之亦然

在PC端，缩放对应布局宽度和视觉窗口宽度都是联动的，而浏览器本身宽度也是固定的，所以不会改变。

\理想视口/
它是对设备来说最理想的布局视口尺寸，即进入浏览器时不需要缩放，宽度为浏览器（屏幕）宽度。
所以就有了一下代码
<meta name="viewport" content="width=device-width">
在IE浏览器中，横竖屏切换会对其造成影响。解决这个兼容性问题最终代码为：
<meta name="viewport" content="width=device-width,initial-scale=1.0">
width=device-width		//把布局视口设置为浏览器宽度
initial-scale=1 					//的意思是初始缩放的比例是1，使用它的时候，同时也会将布局视口的尺寸设置为缩放后的尺寸。
											//而缩放的尺寸就是基于屏幕的宽度来的，也就起到了和width=device-width同样的效果。
	tip:在媒体查询的时候，查询的宽度其实就是布局视口的宽度
	
border-radius 移动端最好不要设计 rem 会变成椭圆 最好设置百分比或者是px



66.
关于line-height
line-height不可以设置百分比，类似border不知道谁是参照物
line-height的高度 为当前行的高度
计算的垂直居中方式为 ( 行高 - 文字高度 ) / 2 的padding值
通过设置上下的padding值把 文字垂直居中



67.
关于0.1+0.2为什么不等于0.3
计算器用位来储存数据。每一个二进制数一一对应十进制数。
	//计算器内部如何表示整数
十进制 13 为 1*10^1 + 3*10^0 = 10 + 3
二进制 13 为 1101 1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 8 + 4 + 0 + 1
	//计算器内部如何表示小数
十进制 0.625 为 6*10^-1 + 2*10^-2 + 5*10^-3 = 0.6 + 0.02 + 0.005
二进制 0.625 为 0.101 1*2^-1 + 0*2^-2 + 1*0^-3 = 1/2 + 0 + 1/8
	//如何用二进制表示0.1
十进制整数转换二进制方法：除2取余
2的二进制为 01  需要把计算后的结果颠倒 其他不用
十进制小数转换二进制方法：乘2除整
栗子🌰
0.1的二进制为
0.1*2			0.2			0
0.2*2			0.4			0
0.4*2			0.8			0
0.8*2			1.6			1
0.6*2			1.2			1
0.2*2			0.4			0
0.4*2			0.8			0
0.8*2			1.6			1
0.6*2			1.2			1
...
所以0.1的二进制为 0.00011001100110011....这是一个二进制无限循环小数，但是计算器内存有限，不能储存所有的小数位数
所以就在精度和内存之间进行了取舍，也就是在某个精度点直接舍弃，代价为0.1并不是精确的0.1，
当代码编译或者解释后，0.1已经被四舍五入为一个与之很接近的内部数字，以至于计算还没开始，误差已经存在
这就是0.1+0.2不等于0.3的原因

有误差的两个小数，其计算的结果，当然 很可能 与我们期望的结果不一样了，因为👇有时会抵消
0.1+0.1为什么等于0.2
两个舍入有误差的值在求和时，相互抵消了，但是这种负负得正，相互抵消不一定是可靠的，
当两个小数用不同长度位数来表示浮点数时候，舍入误差可能不会互相抵消
又如 0.1+0.3 结果其实并不是0.4 但0.4是最接近的数，比其他任何浮点数都接近，许多语言也就直接显示0.4

二进制能够精确的表示位数有限 且分母是2的倍数的小数 比如 0.5
如果需要比较两个浮点数大小的时候，转换成整数再比较 或者 用bignumber.js进行比较

JS中小数比较在小数 16 位数 前进行比较
栗子🌰
console.log(0.1+0.1===0.2000000000000001)					//16位小数					false
console.log(0.1+0.1===0.20000000000000001)				//17位小数					true
console.log(0.1+0.1===0.200000000000000024)				//18位小数					true
console.log(0.1+0.1===0.2000000000000000249)			//19位小数					true
console.log(0.1+0.1===0.200000000000000025)				//18位小数					false
结论：
在小数16位 以前 会用纯数值比较 
16后两位 也就是18位 会依次（18位四舍五入到17位，17→16）四舍五入到16位上 进行比较



68.
关于伪类和元素



69.
关于vertical-align



70.
关于弹性布局 flexbox
\display: flex/ 				  默认转换为行内块元素
flex 布局主要是让容器中的子项目可以根据配置改变自身的宽高及顺序，以最佳的方式填充容器，达到弹性的目的。
容器有横轴和纵轴来划分容器，横轴默认为水平方向纵轴为垂直方向。
		🌙
\flex-direction/			项目的排列方向												//无视div和span特性 直接转换
row 元素从左到右依次排序 																	//默认为文字宽度-可以设置宽高-类似行内块元素
row-reverse 元素从右到左依次排序（类似 text-align right）		//↗
column 元素从上到下依次排序															//默认为屏幕宽度-可以设置宽高-类似行内块元素
column-reverse 元素从下到上依次排序											//↗
		🌙
\flex-wrap/					当容器放不下所有项目时该如何处理
no-wrap 默认值																					//不换行-元素会等分排列-会改变子元素宽度
自适应的排列为加上margin和padding 加上自身内容宽度 如果值太大 不会换行会超出屏幕宽度
wrap 换行																								//向下换行-元素不会等分排列-不会改变子元素宽度
元素不会改变自身宽度 剩下宽度不够width和margin padding的和的话 会换行
wrap-reverse 向上方换行																	//向上换行-元素不会等分排列-不会改变子元素宽度
		🌙
\flex-flow/
flex-flow是flex-direction和flex-wrap两个属性的简写 默认值为 row no-wrap
		🌙
\justify-content/			定义子项目在主轴上的对齐方式（类似text-align）
flex-start 默认值 左对齐																		//会把margin和padding计算进去
flex-end 右对齐																					//↗  
center 居中																							//两边空出等宽-会把margin和padding计算进去
space-between 两边不留白（除了margin）剩下均分 如果数据变多 会把元素宽度减少 如果再多 会消失变白
space-around 两边留白 留白宽度为 两个元素中间宽度的二分之一
（在元素宽度不变小的前提下，如果元素变多 宽度变小 效果和space-between一样）
		🌙
\align-items/				定义项目在纵轴上的对齐方式
flex-start 默认值 上对齐（元素在顶端）
flex-end 下对齐（元素在底部）
center 垂直居中
stretch 子元素高度充满父元素，如果子元素设置了高度无效 设置auto
baseline 子元素所有文字根据 字体最大的底部对齐 需要对齐的元素进行相对应的距离上放位置的偏移
		🌙



71.
关于try和catch
try{
	//执行可能会报错的代码
}catch(err){
	console.log(err)					//如果其中不写代码相关内容 则会跳过错误继续往下执行
}

var val=[];
var getVal=(arr,node,title,url,must)=>{
	for(let x=0;x<arr.length;x++){
		if(arr[x][must]*1===1)val.push({title:arr[x][title],url:arr[x][url]});
		try{getVal(arr[x][node],node,title,url,must)}catch(err){}
	}
}
getVal(arrx,"nodes","title","url","nav_type");
console.log(val);
使用于数组对象数组对象数组嵌套关系中 不知道有多少层 继续往下查找属性 当到最后一层时 会报undefined 所以 需要try catch



72.
关于isNaN的一些用法
isNaN() 对括号内的内容进行判断 如果不是数字则返回true 如果是数字则返回false
会对括号内 内容进行 隐式转换 
如果为字符串 "1" "2" 也返回false
如果为"2018-01"	则返回true
如果字符串为纯数字 也会当作数字处理



73.
jquery获取指定元素以及指定元素的html
类似与js outerHTML
$("元素").prop("outerHTML")	
只可以用 prop 而不可以使用 attr 详见44条


74.
关于attr()和prop()的异同
attr()函数设计的目的是用于 设置或读取 指定DOM元素所对应的文档节点上的属性
prop()函数设计的目的是用于 设置或读取 指定DOM元素（js对象，Element类型）上的属性（property）
在jquery底层中 都是依赖js原生的Element对象实现的
attr() 依赖 getAttribute() 和 setAttribute()	
prop() 依赖 js原生的对象属性获取和设置方式

var msg=document.getElementById("x");
var $msg=$(msg);

$msg.attr("class","qwe")				//相当于 msg.setAttribute("class","qwe")
$msg.attr("class")							//相当于 msg.getAttribute("class")

$msg.prop("x","x值")					//相当于 msg["x"]="x值"
$msg.prop("x")								//相当于 msg["x"]

虽然prop()访问的为js对象的property，不过DOM元素某些属性的更改也会影响到元素节点上对应的属性
例如，property的id对应attribute的id 或者 property的className对应attribute的class

attr()为 jquery 1.0就有的函数  而  prop()为 jquery 1.6才有的函数

由于attr()函数操作的是文档节点的属性，因此设置的属性只能是字符串类型，如果不是字符串类型，则会调用 toString()方法，将转化为字符串
prop()函数操作的是js对象的属性，因此可以设置的属性为 数组和对象在内的任意类型

对于表单元素的 checked,selected,disabled等属性 
在jquery 1.6之前 attr()获取这些属性的返回值为 Boolean类型 ： 如果被选中或禁用 就返回 true 否则返回 false
在jquery 1.6之后 attr()获取这些属性返回为 String类型，如果选中或禁用 就返回 "checked","selected","disabled"等属性 否则返回 undefined

并且在某些版本中，这些属性表示文档加载初始值，不会随更改进行响应
而property的checked,selected,disabled才表示该属性实时的值(true 或 false)
因此在 jqeury 1.6之后 使用prop获取 checked，selected，disabled等属性，能够使用prop()实现的 尽量使用prop()



75.
关于图片懒加载
条件:	①图片距离最顶部(浏览器顶部)高度 < ②当前屏幕高度 + ③滚动过的距离		如果相等 则代表 屏幕下一PX为图片内容

	①图片距离顶部高度 /js方法
	function getTop(ele){
	
		let topx=ele.offsetTop;
		let father=ele.offsetParent;
		while(father!==null){
			topx+=father.offsetTop;
			father=father.offsetParent
		}
		return topx
	}
	
	②当前屏幕高度
	window.innerHeight
	
	③滚动过的距离
	document.documentElement.scrollTop

整体函数为
function funx(){
	let imgx=document.getElementsByTagName("img");
	for(let x=0;x<imgx.length;x++){
		if(getTop(img[x])<window.innerHeight+document.documentElement.scrollTop){
			imgx[x].src=imgx[x].getAttribute("data-src");					//把真实路径设置在data-src中 src使用小图片代替或者不设
		}
	}
}
funx();
window.onscroll=funx


以及函数节流
function jieliu(times,funcx){
	let zuihou=0;
	return function(){
		let x=new Date();				//需要命名保存 因为时间会变
		if(x-zuihou>times){
			funcx();
			zuihou=x;
		}
	}
}

window.onscroll=jieliu(500,funx);			//把滚动事件 变为节流函数



76.
关于document.write()和document.writeln()的区别
一个是以行输出 一个是一内联输出
页面上为 一个有空格 一个无空格



77.
关于Javascript中的继承
	
	一、简介

	function gouzao(name,age){
		var sex="girl";						//①
		this.name=name;					//②
		this.age=age;
	}
	gouzao.prototype.yuanxing=function(){			//③
		alert(this.name)
	}
	var shili=new gouzao("二宝","21");					//④
	shili.yuanxing();												//弹出二宝

	gouzao为一个"构造函数" ①为构造函数的私有属性 ②为构造函数的自有属性
	③处的prototype为gouzao的"原型对象"（他是构造函数的原型，是一个对象，也是构造函数的属性，也称之为 原型属性）
		该对象上的所有属性和方法，都会被"实例对象"继承
	④为"构造函数"gouzao的"实例对象"（它是由构造函数生成的一个实例，同时也是一个对象）
		可以访问到两种属性，一种是通过构造函数生成的自有属性，另一种是原型属性上的所有属性

	重点：
		1.每一个对象都有一个隐式的[[proto]]属性，该属性是默认指向其构造函数原型属性的指针
		2.几乎所有函数都拥有prototype原型属性
	
	当javascript引擎发现一个对象访问一个属性时候，先会查找对象的自有属性，如果没找到 会在 [[proto]]指向的原型属性中继续查找，
	如果还没有找到的话，原型属性其实也是一个对象，也是有隐式的[[proto]]属性，所以会继续往下找，知道找到最顶部的Object 如果还没有找到，会返回undefined
		这个过程叫 攀爬原型链
	
	隐式的[[proto]]可以通过Chorme浏览器中的_proto_属性访问（每个对象都有隐式的_proto_属性）
	
	二、继承
	
	继承：一个对象想要访问另一个对象的属性，同时 这个对象还可以添加自己的新属性或者是覆盖可访问的另一个对象的属性，实现这个目标的方式 就叫 "继承"
	
	因为当对象 访问一个属性的时候，首先会看构造函数的自有属性，如果没有的话，就会查找[[proto]]也就是原型属性，所以
	如果要继承某个对象内的属性的话，把没有属性的对象的[[proto]]修改为 有属性 需要继承的对象
	
	在javascript中 实现继承的方式 有两种：
		1.创建一个对象并指定其继承对象（原型属性）；
		2.修改构造函数的原型属性
			
	对于一个已经定义的对象，无法改变其继承关系。
	因为设置一个对象的继承关系，本质上是在操作对象隐式的[[proto]]属性，
	而javascript只开通了创建时定义[[proto]]的权限，而拒绝让我们在对象定义时再修改或访问这一属性（因为是隐式的）;
	在对象创建够改变其继承关系是不可能的
	
	Object.create()函数是Javascript一个在创建对象时设置内部[[proto]]属性的API，通过修改[[proto]]属性的值，就能决定对象所继承的对象
	var x={
		name:"二宝",
		sayname:function(){
			console.log(this.name);
		}
	}
	var y=Object.create(x,{
		name:{
			value:"二狗",
			configurable: true,
	        enumerable: true,
	        writable: true,
		}
	})
	y.sayname();				//二狗
	第一个参数为想要继承的原型对象，第二个参数为一个属性描述对象，然后会返回一个对象
	
	在调用Object.create()时发生了
		1.创建一个空对象，并赋值给相应变量;
		2.将第一个参数设置为该对象的[[proto]]属性的值;
		3.在该对象上调用Object.defineProperty(),并将第二个参数传入该方法中;
			（Object.defineProperty()会直接在一个方法上定义一个属性，或者修改对象的现有属性，并返回这个对象）
	
	局限性：创建对象时设置对象的继承对象，继承方式是一次性的

	构造函数生产实例对象的过程本身就是一种天然的继承。共有两层
		自定义构造函数的prototype对象继承Object构造函数（最顶部构造函数）的prototype属性；
		构造函数实例对象继承构造函数原型属性；
		
	因为 每一个对象都有一个隐式的[[proto]]属性，该属性默认指向其构造函数原型属性
	又因为 原型属性也是一个对象，所以也拥有[[proto]]属性，所以也会指向其构造函数的原型属性，所以也会继承其原型属性的
	↓ 所以 只需要修改原型属性的[[proto]]属性即可↙ （但是修改的时候，只可以在创建时候修改，因为javascript只开通了创建时定义[[proto]]的权限）
	
	构造函数继承
	var x=function(name,age){
		var name="二狗";
		this.name=name;
		this.age=age;
	}
	x.prototype.look=function(){
		console.log(this.name);
	}
	x.prototype.look1=function(){
		console.log(this.age)
	}
	x.prototype.look2=function(){
		console.log(this.bf)
	}
	var z=function(name,age){
		this.name=name;
		this.age=age;
		this.bf="大宝"
	}
	z.prototype=Object.create(x.prototype)				//只有在创建时候才可以定义[[proto]]的值 所以要继承的话 要写在原型属性的方法的上方
	var xx=new z("二宝","21");
	xx.look();																//二宝
	xx.look1();																//21
	xx.look2();																//大宝
	
	Q:如果想访问x内的自有属性（所继承的构造函数的自有属性）怎么办？山西大同找鸿翔并且使用　call()	方法
	
	构造函数窃取
	var x=fucntion(name,age){
		var name="二狗";
		this.name=name;
		this.age=age;
		this.bf="大宝";
	}
	x.prototype.look=function(){
		console.log(this.name);
	};
	x.prototype.look1=function(){
		console.log(this.age);
	};
	x.prototype.look2=function(){
		console.log(this.bf)
	};
	var z=function(name,age){
		x.call(this,name,age)						//把 x 的this指向了当前的this，把 z 里的name和age当作参数传递到 x 里（因为x有形参）
	}
	z.prototype=Object.create(x.prototype);
	var xx=new z("二宝",21);
	z.look();											// "二狗"				私有属性优先级比较高,如果把var去掉 则显示	二宝
	z.look1();											//21						没什么特别的
	z.look2();											//"大宝"				成功的获取到了 x函数内的自有属性（所继承的构造函数的自有属性）
	
	图 www.cnblogs.com/libinfs/p/6835640.html
	
	function Animal (name) {
	  // 属性
	  this.name = name || 'Animal';
	  // 实例方法
	  this.sleep = function(){
	    console.log(this.name + '正在睡觉！');
	  }
	}
	// 原型方法
	Animal.prototype.eat = function(food) {
	  console.log(this.name + '正在吃：' + food);
	};
	
	function Cat(){ 
	}
	Cat.prototype = new Animal();
	Cat.prototype.name = 'cat';
	
	//　Test Code
	var cat = new Cat();
	console.log(cat.name);
	console.log(cat.eat('fish'));
	console.log(cat.sleep());
	console.log(cat instanceof Animal); //true 
	console.log(cat instanceof Cat); //true
	


78.
关于深入js中的函数各方面



79.
关于Javascript调试命令 /console
console对象提供对浏览器控制台的接入。不同浏览器的上的工作方式是不同的。
console对象可以在任何全局对象中访问，它被浏览器定义为Window.Console，也可以被简单的Console调用

不同类别信息输出
console.log("文字信息");
console.info("提示信息");
console.warn("警告信息");
console.error("错误信息");

分组输出	(group)
console.group("-----");						//展开的分组
console.log("文字信息");
console.info("提示信息");
console.groupEnd();							//需要用此关闭

console.groupCollapsed("折叠了")	//闭合的分组
console.warn("警告信息");
console.error("错误信息");
console.groupEnd();							//用此关闭
	还可以嵌套使用
	console.group("-----");						//展开的分组
	console.log("文字信息");
	console.groupCollapsed("内1")
	console.info("提示信息");
	console.groupEnd();
	console.groupEnd();							//需要用此关闭
	
表格输出	(table)
let x={
	a:{
		name:"11",
		age:"11"
	},
	b:{
		name1:"22",
		age1:"22"
	},
	c:{
		name2:"33",
		age2:"33"
	},
}
let z=[
	[1,2,3],
	[2,3,4],
	[3,4,5],
]
console.table(x);
console.table(z)

查看对象	(dir)
console.dir(	)显示一个对象的属性和方法
在Chrome中console.log()与console.dir()效果相同;
let x={
	a:{
		name:"11",
		age:"11"
	},
	b:{
		name1:"22",
		age1:"22"
	},
	c:{ 
		name2:"33",
		age2:"33"
	},
}
console.dir(x);
console.log(dir);

查看节点	(dirxml)
在Chrome中 console.dirxml() 与 console.log()		效果相同
<div id="aa"></div>
console.dirxml(document.querySelector("#aa"));
console.log(document.querySelector("#aa"));

条件输出	(assert)
console.assert(true,"永远看不到我");
console.assert(false,"你可以看到我");
console.assert((function(){return false}()),"可以看到我");
console.assert((function(){return true}()),"永远看不到");
自调用函数 用48条 824行的多数方法不行

计次输出	(count)
for(let x=0;x<10;x++){
	console.count("输入内容");
}
次数从1开始；
如果输入内容，会自带中文冒号；		console.count("我今年：")
输入相同内容，则会累计次数；
不同文字，次数累计不同；
如果不输入内容，则不会叠加；			console.count()
在循环内不输入内容，会叠加；

追踪调用堆栈		(trace)
function a(){
	console.trace()
}
function b(){
	a()
}
function c(){
	b()
}
c();
会按照冒泡原理 从最内层往上依次显示当前堆栈，执行环境

计时功能	(time timeEnd)
console.time();
console.timeEnd("完成时间");
在timeEnd里不加文字会显示	default;
加了文字会显示文字内容 默认加中文冒号；会以ms为显示



80.
关于事件冒泡和捕获
点击某个事件执行顺序 捕获 目标阶段 冒泡
如果想阻止 event.stopPropagation()



81.
关于随机排列数组
var arr=[1,2,3,4,5,6,7,8,9,10];
arr.sort(()=>{
	let x=Math.random();
	console.log(arr);
	console.log(x);
	console.log("--------------------")
	return x-.5
})
console.log(arr)
如果随机数大于0.5会一直排列下去 直到小于0.5或者排列到第一位



82.
关于判断设备来源 以及 是否微信
function deviceType(){
    var ua = navigator.userAgent;
    var agent = ["Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod"];    
    for(var i=0; i<len,len = agent.length; i++){
        if(ua.indexOf(agent[i])>0){         
            break;
        }
    }
}
deviceType();
window.addEventListener('resize', function(){
    deviceType();
})


微信的 有些不太一样
function isWeixin(){
    var ua = navigator.userAgent.toLowerCase();
    if(ua.match(/MicroMessenger/i)=='micromessenger'){
        return true;
    }else{
        return false;
    }
}



83.
关于监听复制按键
$("#aa").keydown(function(event){
	console.log(event.keyCode);
	if(event.keyCode===67&&event.ctrlKey===true){
		console.log("不许复制")
		return false;
	}
})					//监听按键的ctrl+c
document.body.oncopy = function (){
	console.log("不许复制")
	return false;
}					//监听鼠标右键的复制



84.
call会运行对象内的函数	x.xx.call(window)



85.
关于jquery选择器的 :gt 和 :lt
$("#fu div:gt(2)").hide() 选择前三个元素之后的元素 并且隐藏 从第四个开始 数字为下标
$("#fu div:lt(2)").hide() 选择第三个元素之前的元素 并且隐藏
下标为2的元素会一直存在



86.
有时给子元素设置margin-top时候，父元素会掉下来，会与子元素顶部对齐。
原因:
	一个盒子如果没有上补白(padding-top)和上边框(border-top)，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠。
所以 解决方式为给父元素设置 padding-top或者border-top或者overflow:hidden或者position:absolute float:right



87.
获取对象的key值 不使用 for in 为 Object.keys(对象)
